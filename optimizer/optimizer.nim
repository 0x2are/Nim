#
#
#             C Optimizer
#        (c) Copyright 2020 Andreas Rumpf
#
#    See the file "copying.txt", included in this
#    distribution, for details about the copyright.
#

## An optimizer that optimizes the C code that Nim produces
## even further.
## Planned Optimizations:
## - basic inlining
## - destructor sinking
## - wasMoved(x); =destroy(x) elimination
## - merge generic instantiations

import ".." / compiler / [options, llstream, pathutils]

import clexer, bitabs
import std / [hashes, os, tables]

type
  Ir = object
    tokens: seq[Id]
    literals: BiTable[string]

  ProcDef = object
    name: Id
    first, last: int

  TokenReplacements = seq[(Id, Id)]

proc writeIr(ir: Ir; filename: string) =
  let outf = open(filename, fmWrite)
  for id in ir.tokens:
    if isBuiltin(id):
      if id != NullId:
        outf.write(tokKindToStr TokenKind(id))
    else:
      outf.write(ir.literals[id])
  close outf

proc writeIr(ir: Ir; filename: string; replacements: TokenReplacements) =
  let outf = open(filename, fmWrite)
  for id in ir.tokens:
    if isBuiltin(id):
      if id != NullId:
        outf.write(tokKindToStr TokenKind(id))
    else:
      block search:
        for (this, by) in items(replacements):
          if this == id:
            outf.write(ir.literals[by])
            break search
        outf.write(ir.literals[id])
  close outf

proc hashProc(ir: Ir; p: ProcDef): Hash =
  # we ingore the function name not only in the header, but also
  # in the body so that we also recognize recursive functions.
  const selfToken = Id(255)
  var h: Hash = 0
  for i in p.first..p.last:
    if ir.tokens[i] == p.name:
      h = h !& hash(selfToken)
    else:
      h = h !& hash(ir.tokens[i])
  result = !$h

# Functions generated by Nim start with either N_LIB_PRIVATE or N_LIB_EXPORT.
# That makes them really easy to parse.

const
  ProcDeclKeyw = Id(256)

proc analyse(ir: var Ir) =
  var i = 0
  var procStart = -1
  var bodyStart = -1
  var curlies = 0
  var procName: Id

  var bodies = initTable[Hash, seq[ProcDef]]()

  while i < ir.tokens.len:
    if not ir.tokens[i].isBuiltin:
      if curlies == 0 and ir.tokens[i] == ProcDeclKeyw:
        procStart = i
    else:
      let kind = TokenKind(ir.tokens[i])
      case kind
      of tkParRi:
        # N_LIB_PRIVATE N_NIMCALL(void, rawInsert)
        #                                        ^ we're here
        # the procname was before this ')'
        if procStart >= 0 and procName == NullId and not ir.tokens[i-1].isBuiltin:
          procName = ir.tokens[i-1]
          when false:
            echo "proc found ", ir.literals[procName]
          bodyStart = i+1

      of tkSemiColon:
        if procStart >= 0 and curlies == 0:
          # it is a function prototype:
          procStart = -1
          procName = NullId
      of tkCurlyLe:
        inc curlies
      of tkCurlyRi:
        if procStart >= 0 and curlies == 1:
          let thisProc = ProcDef(name: procName, first: procStart, last: i)
          let bodyHash = hashProc(ir, thisProc)
          if not bodies.hasKey(bodyHash):
            bodies[bodyHash] = @[thisProc]
          else:
            bodies[bodyHash].add thisProc

          procName = NullId
          procStart = -1
        if curlies > 0:
          dec curlies
      else:
        discard
    inc i
  # let's look for the duplicate functions:
  var replacements: TokenReplacements
  for k, procSet in mpairs(bodies):
    if procSet.len >= 2:
      for i in 1 ..< procSet.len:
        # remove function body:
        for ti in procSet[i].first .. procSet[i].last:
          ir.tokens[ti] = NullId
        replacements.add((procSet[i].name, procSet[0].name))
  if replacements.len > 0:
    writeIr(ir, os.getAppDir() / "tables_copy.c", replacements)
  echo "yeah ", replacements.len

proc main(f: AbsoluteFile) =
  let fs = llStreamOpen(f, fmRead)
  if fs == nil:
    echo "[Error] cannot open file ", f.string
    quit 1

  var lex: Lexer
  openLexer(lex, f, fs, newConfigRef())
  var tok: Token
  var ir: Ir
  let check = ir.literals.getOrIncl("N_LIB_PRIVATE")
  assert check == ProcDeclKeyw
  # first turn it into an effective token stream:
  while true:
    getTok(lex, tok)
    case tok.kind
    of tkSymbol, tkInvalid, tkStarComment, tkLineComment, tkLit, tkNewLine, tkWhitespace:
      let id = ir.literals.getOrIncl(tok.s)
      ir.tokens.add id
    of tkEof: break
    else:
      ir.tokens.add(Id(tok.kind))

  closeLexer(lex)
  analyse(ir)


import times, strutils
let t = epochTime()
main AbsoluteFile(os.getAppDir() / "tables.c")
echo("Completed in ", $(epochTime() - t), "s. Success! Peak mem ", formatSize getMaxMem())
